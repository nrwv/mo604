import MetaTrader5 as mt5
import pandas as pd
import talib as ta
import requests
import time
import numpy as np
from datetime import datetime
from sklearn.neural_network import MLPClassifier
import csv
from sklearn.ensemble import RandomForestClassifier
import matplotlib.pyplot as plt
from datetime import datetime, timedelta
import concurrent.futures

# Step 1: API Key and Endpoint for NewsAPI (replace with your API service)
NEWS_API_KEY = "your_api_key_here"  # Replace with your API key
NEWS_API_URL = "https://newsapi.org/v2/everything"

# Step 2: Fetch Real-Time News Data
def fetch_real_time_news():
    parameters = {
        'q': 'forex OR stock market OR interest rates OR economy',  # Keywords to filter financial news
        'apiKey': NEWS_API_KEY,
        'language': 'en',
        'sortBy': 'publishedAt'
    }
    
    response = requests.get(NEWS_API_URL, params=parameters)
    if response.status_code == 200:
        news_data = response.json()
        return news_data['articles'][:5]  # Get the latest 5 news articles
    else:
        print("Failed to fetch news, check your API key and connection.")
        return None

# Step 3: Analyze News for Important Events
def analyze_news_for_events(news_data):
    important_keywords = ["interest rate", "non-farm payroll", "inflation", "central bank", "GDP"]
    for article in news_data:
        for keyword in important_keywords:
            if keyword in article['title'].lower() or keyword in article['description'].lower():
                print(f"Important event detected: {article['title']}")
                return True
    return False

# Step 4: Automated Trading Pauses Based on News
def news_monitor():
    news_data = fetch_real_time_news()
    if news_data:
        if analyze_news_for_events(news_data):
            print("Important economic event detected. Pausing trading...")
            return True
    return False

# Step 5: Initialize the connection to MetaTrader 5
def initialize_mt5():
    if not mt5.initialize():
        print(f"Initialization failed, error code: {mt5.last_error()}")
        return False
    print("MetaTrader 5 initialized successfully!")
    return True

# Step 6: Login to MetaTrader 5 account
def login_to_account(account, password, server):
    if mt5.login(account, password=password, server=server):
        print(f"Connected to account #{account}")
    else:
        print(f"Failed to connect to account #{account}, error code: {mt5.last_error()}")



# Function to calculate ATR (Average True Range)
def calculate_atr(data, period=14):
    if 'high' in data.columns and 'low' in data.columns and 'close' in data.columns:
        data['ATR'] = ta.ATR(data['high'], data['low'], data['close'], timeperiod=period)
    else:
        print("Error: Data does not contain necessary columns for ATR calculation.")
    return data

# Fetch historical data with volume
def fetch_historical_data(symbol="EURUSD", timeframe=mt5.TIMEFRAME_H1, years=5):
    # Ensure MetaTrader 5 is initialized
    if not initialize_mt5():
        return None

    # Set the date range
    end_date = datetime.now()
    start_date = end_date - timedelta(days=years * 365)

    # Fetch historical data including volume
    rates = mt5.copy_rates_range(symbol, timeframe, start_date, end_date)

    # If no data is found
    if rates is None or len(rates) == 0:
        print(f"Failed to retrieve data for {symbol}")
        mt5.shutdown()
        return None

    # Convert to DataFrame
    data = pd.DataFrame(rates)

    # Convert the time from timestamp to datetime
    data['time'] = pd.to_datetime(data['time'], unit='s')

    # Show first few rows of the data
    print(f"Fetched {len(data)} rows of historical data from {start_date.date()} to {end_date.date()}")
    print(data.head())

    # Ensure the volume data is available
    if 'volume' not in data.columns:
        print("Volume data is missing in the fetched data.")

    # Shutdown MetaTrader 5 connection
    mt5.shutdown()

    return data

# Fetch the historical data
historical_data = fetch_historical_data("EURUSD", mt5.TIMEFRAME_H1, 5)

# Function to calculate RSI and MACD
def calculate_rsi_macd(data):
    """
    Function to calculate RSI and MACD for the given data.
    """
    if 'close' in data.columns:
        data['RSI'] = ta.RSI(data['close'], timeperiod=14)
        data['MACD'], data['MACD_signal'], _ = ta.MACD(data['close'], fastperiod=12, slowperiod=26, signalperiod=9)
    else:
        print("Error: Data does not contain 'close' column for RSI and MACD calculation.")
    return data

# Function to detect confluence of multiple signals (e.g., RSI and MACD)
def detect_confluence_signals(data):
    """
    Function to detect the confluence of RSI and MACD signals.
    """
    if 'RSI' not in data.columns or 'MACD' not in data.columns:
        raise KeyError("'RSI' or 'MACD' is missing in the data. Ensure the calculate_rsi_macd function is called.")

    for i in range(1, len(data)):
        rsi = data['RSI'].iloc[i]
        macd = data['MACD'].iloc[i]
        macd_signal = data['MACD_signal'].iloc[i]

        # Confluence of RSI buy signal and MACD crossover
        if rsi < 30 and macd > macd_signal:
            print(f"Confluence Buy signal at {data['time'].iloc[i]}")
        
        # Confluence of RSI sell signal and MACD crossover
        elif rsi > 70 and macd < macd_signal:
            print(f"Confluence Sell signal at {data['time'].iloc[i]}")

# Example Usage
# Ensure you calculate RSI and MACD before detecting confluence signals
historical_data = calculate_rsi_macd(historical_data)
detect_confluence_signals(historical_data)






# Step 7: Get symbol data (e.g., EURUSD)
def get_symbol_data(symbol):
    symbol_info = mt5.symbol_info(symbol)
    if symbol_info is None:
        print(f"Symbol {symbol} not found")
        return None
    if not symbol_info.visible:
        print(f"{symbol} is not visible, trying to switch on")
        if not mt5.symbol_select(symbol, True):
            print(f"Failed to activate {symbol}")
            return None
    return symbol_info

# Step 5: Standard Order Placement (for example purposes)
def place_order(symbol, order_type, lot, sl, tp):
    symbol_info = get_symbol_data(symbol)
    if symbol_info is None:
        print(f"Cannot get symbol info for {symbol}")
        return

    price = mt5.symbol_info_tick(symbol).ask if order_type == 'buy' else mt5.symbol_info_tick(symbol).bid
    point = symbol_info.point

    request = {
        "action": mt5.TRADE_ACTION_DEAL,
        "symbol": symbol,
        "volume": lot,
        "type": mt5.ORDER_TYPE_BUY if order_type == 'buy' else mt5.ORDER_TYPE_SELL,
        "price": price,
        "sl": price - sl * point if order_type == 'buy' else price + sl * point,
        "tp": price + tp * point if order_type == 'buy' else price - tp * point,
        "deviation": 20,
        "magic": 123456,
        "comment": "Python Bot",
        "type_time": mt5.ORDER_TIME_GTC,
        "type_filling": mt5.ORDER_FILLING_IOC,
    }

    # Send the trading request
    result = mt5.order_send(request)
    if result.retcode != mt5.TRADE_RETCODE_DONE:
        print(f"Order failed, retcode={result.retcode}")
    else:
        print(f"Order placed successfully: {order_type} {symbol} at {price}")

# Main execution
if __name__ == "__main__":
    account_number = 87091924  # Replace with your account number
    account_password = "M!1pPuUm"  # Replace with your account password
    account_server = "MetaQuotes-Demo"  # Replace with your broker server

    # Initialize MetaTrader 5
    if initialize_mt5():
        # Login to the account
        login_to_account(account_number, account_password, account_server)

        # Place a basic buy order on EURUSD with stop loss and take profit
        place_order("EURUSD", "buy", lot=0.1, sl=100, tp=200)

        # Close MetaTrader 5 connection
        mt5.shutdown()

# Dynamic Lot Sizing, Trailing Stop, and Advanced Analysis Functions

# Function to calculate dynamic lot size based on account balance, risk, and volatility
def calculate_dynamic_lot_size(account_balance, risk_percent, stop_loss_pips, atr_value, market_volatility):
    # Adjust risk based on market volatility
    adjusted_risk_percent = risk_percent * (1 / market_volatility)  # Reduce risk in high volatility environments
    risk_amount = account_balance * (adjusted_risk_percent / 100)
    lot_size = risk_amount / (stop_loss_pips * atr_value)
    return round(lot_size, 2)

# Function to adjust trailing stop loss based on current price and ATR
def advanced_trailing_stop(current_price, entry_price, initial_stop_loss, atr_value, trailing_multiplier=2):
    trailing_distance = atr_value * trailing_multiplier
    if current_price - entry_price >= trailing_distance:
        new_stop_loss = max(initial_stop_loss, current_price - trailing_distance)
        return new_stop_loss
    return initial_stop_loss

# Function to calculate RSI and MACD
def calculate_rsi_macd(data):
    data['RSI'] = ta.RSI(data['close'], timeperiod=14)
    data['MACD'], data['MACD_signal'], _ = ta.MACD(data['close'], fastperiod=12, slowperiod=26, signalperiod=9)
    
    # Filters based on volume and volatility
    data['Volume_Filter'] = data['volume'] > data['volume'].rolling(window=50).mean()
    data['Volatility_Filter'] = data['close'].rolling(window=10).std() > 0.002
    return data

# Function to generate buy/sell signals based on advanced indicators (RSI, MACD, Volume, and Volatility)
def generate_advanced_signals(data):
    for i in range(1, len(data)):
        # RSI Buy signal with volume filter
        if data['RSI'].iloc[i] < 30 and data['Volume_Filter'].iloc[i]:
            print(f"RSI Buy signal at {data['time'].iloc[i]}")
        
        # RSI Sell signal with volume filter
        elif data['RSI'].iloc[i] > 70 and data['Volume_Filter'].iloc[i]:
            print(f"RSI Sell signal at {data['time'].iloc[i]}")

        # MACD Buy signal with volatility filter
        if data['MACD'].iloc[i] > data['MACD_signal'].iloc[i] and data['Volatility_Filter'].iloc[i]:
            print(f"MACD Buy signal at {data['time'].iloc[i]}")
        
        # MACD Sell signal with volatility filter
        elif data['MACD'].iloc[i] < data['MACD_signal'].iloc[i] and data['Volatility_Filter'].iloc[i]:
            print(f"MACD Sell signal at {data['time'].iloc[i]}")


# Function to backtest a strategy
def backtest_strategy(symbol, data, strategy_function):
    initial_balance = 10000
    balance = initial_balance
    trade_count = 0
    winning_trades = 0
    losing_trades = 0

    for i in range(1, len(data)):
        trade_result = strategy_function(data.iloc[i], balance)
        if trade_result is not None:
            trade_count += 1
            balance += trade_result
            if trade_result > 0:
                winning_trades += 1
            else:
                losing_trades += 1

    win_rate = (winning_trades / trade_count) * 100 if trade_count > 0 else 0
    print(f"Total Trades: {trade_count}, Win Rate: {win_rate:.2f}%")
    print(f"Final Balance: {balance:.2f}, Initial Balance: {initial_balance}")

# Function to detect an advanced hammer candlestick pattern
def detect_advanced_hammer_pattern(data):
    for i in range(1, len(data)):
        body = abs(data['open'].iloc[i] - data['close'].iloc[i])
        lower_wick = data['low'].iloc[i] - min(data['open'].iloc[i], data['close'].iloc[i])
        
        # Identify hammer pattern
        if lower_wick > 2 * body and (data['high'].iloc[i] - max(data['open'].iloc[i], data['close'].iloc[i])) < body:
            if data['volume'].iloc[i] > data['volume'].rolling(window=50).mean():  # Confirm by volume
                print(f"Hammer pattern confirmed by volume at {data['time'].iloc[i]}")

# Function to detect the Gartley harmonic pattern using Fibonacci ratios
def detect_gartley_pattern(data):
    for i in range(5, len(data)):
        X = data['high'][i-4]
        A = data['low'][i-3]
        B = data['high'][i-2]
        C = data['low'][i-1]
        D = data['high'][i]

        # Check for Gartley pattern using Fibonacci retracement ratios
        if 0.618 < (B - A) / (X - A) < 0.786 and 0.618 < (D - C) / (B - C) < 0.786:
            print(f"Gartley pattern detected at {data['time'].iloc[i]}")


# Example: Applying harmonic pattern detection to your data
detect_gartley_pattern(historical_data)

# Function to check if the current time is within specific market hours
def is_market_open():
    current_time = datetime.utcnow().time()

    # Define market sessions (UTC times for example)
    london_open = datetime.strptime("08:00:00", "%H:%M:%S").time()
    london_close = datetime.strptime("16:30:00", "%H:%M:%S").time()

    new_york_open = datetime.strptime("13:30:00", "%H:%M:%S").time()
    new_york_close = datetime.strptime("20:00:00", "%H:%M:%S").time()

    # Check if current time is within London or New York market hours
    if london_open <= current_time <= london_close or new_york_open <= current_time <= new_york_close:
        return True
    else:
        return False

# Function to place orders only during market hours
def place_order_during_market_hours(symbol, order_type, lot, sl, tp):
    if is_market_open():
        place_order(symbol, order_type, lot, sl, tp)  # Assuming place_order is already defined elsewhere
    else:
        print("Market is closed. Order not placed.")

# Example: Attempt to place an order during market hours
place_order_during_market_hours("EURUSD", "buy", 0.1, 100, 200)









# Function to detect double top pattern (reversal pattern)
def detect_double_top(data):
    for i in range(2, len(data)):
        # Check if the two previous highs are equal and the current close is lower than the previous low
        if data['high'].iloc[i-2] == data['high'].iloc[i-1] and data['close'].iloc[i] < data['low'].iloc[i-1]:
            print(f"Double top detected at {data['time'].iloc[i]}")

# Function to detect head and shoulders pattern (reversal pattern)
def detect_head_and_shoulders(data):
    for i in range(3, len(data)):
        left_shoulder = data['high'].iloc[i-3]
        head = data['high'].iloc[i-2]
        right_shoulder = data['high'].iloc[i-1]
        neckline = data['low'].iloc[i]

        # Check if the left and right shoulders are lower than the head and the neckline is lower than both shoulders
        if left_shoulder < head and right_shoulder < head and neckline < min(left_shoulder, right_shoulder):
            print(f"Head and Shoulders pattern detected at {data['time'].iloc[i]}")

# Example: Detect reversal patterns
detect_double_top(historical_data)
detect_head_and_shoulders(historical_data)







# Function to calculate Bollinger Bands and trade based on volatility
def bollinger_bands_trading(data, window=20, num_std_dev=2):
    data['SMA'] = data['close'].rolling(window=window).mean()
    data['STD'] = data['close'].rolling(window=window).std()

    data['Upper_Band'] = data['SMA'] + (num_std_dev * data['STD'])
    data['Lower_Band'] = data['SMA'] - (num_std_dev * data['STD'])

    # Generate buy/sell signals based on Bollinger Bands breakout
    for i in range(1, len(data)):
        if data['close'].iloc[i] > data['Upper_Band'].iloc[i]:
            print(f"Bollinger Bands Sell signal at {data['time'].iloc[i]}")
        elif data['close'].iloc[i] < data['Lower_Band'].iloc[i]:
            print(f"Bollinger Bands Buy signal at {data['time'].iloc[i]}")

# Example: Trade based on Bollinger Bands
bollinger_bands_trading(historical_data)


# Function to detect price gaps and place trades
def detect_price_gaps(data):
    for i in range(1, len(data)):
        previous_close = data['close'].iloc[i-1]
        current_open = data['open'].iloc[i]
        
        # Check for a gap up or gap down
        if current_open > previous_close * 1.01:  # Gap up more than 1%
            print(f"Gap up detected at {data['time'].iloc[i]}")
        elif current_open < previous_close * 0.99:  # Gap down more than 1%
            print(f"Gap down detected at {data['time'].iloc[i]}")

# Example: Detect price gaps in the data
detect_price_gaps(historical_data)








# Function to detect confluence of multiple signals (e.g., RSI and MACD)
def detect_confluence_signals(data):
    for i in range(1, len(data)):
        rsi = data['RSI'].iloc[i]
        macd = data['MACD'].iloc[i]
        macd_signal = data['MACD_signal'].iloc[i]

        # Confluence of RSI buy signal and MACD crossover
        if rsi < 30 and macd > macd_signal:
            print(f"Confluence Buy signal at {data['time'].iloc[i]}")

        # Confluence of RSI sell signal and MACD crossover
        elif rsi > 70 and macd < macd_signal:
            print(f"Confluence Sell signal at {data['time'].iloc[i]}")

# Example: Detect confluence of signals
detect_confluence_signals(historical_data)


# Function to analyze liquidity based on available columns
def analyze_liquidity(data):
    """
    Analyze liquidity based on available columns.
    If volume is missing, use price movement as a proxy.
    """
    if 'volume' in data.columns:
        # Use volume as a proxy for liquidity
        data['Liquidity'] = data['volume'] / data['volume'].rolling(window=50).mean()
    else:
        # If volume is missing, use price volatility (high - low) as a proxy
        data['Liquidity'] = (data['high'] - data['low']) / (data['close'].rolling(window=50).mean())

    # Detect high and low liquidity conditions
    for i in range(1, len(data)):
        if data['Liquidity'].iloc[i] > 1.5:  # High liquidity, strong market
            print(f"High Liquidity detected at {data['time'].iloc[i]}.")
        elif data['Liquidity'].iloc[i] < 0.75:  # Low liquidity, weak market
            print(f"Low Liquidity detected at {data['time'].iloc[i]}.")







def smart_trade_filters(data):
    """
    Function to apply smart trade filters based on market conditions.
    If volume data is not available, use price volatility as an alternative.
    """
    # Check if 'volume' column is available
    if 'volume' in data.columns:
        # Filter based on volume if available
        data['Volume_Filter'] = data['volume'] > data['volume'].rolling(window=50).mean()  # High volume filter
    else:
        # If volume is missing, use volatility (price range) as a proxy
        data['Volume_Filter'] = (data['high'] - data['low']) > (data['high'] - data['low']).rolling(window=50).mean()

    # Filter based on volatility
    data['Volatility_Filter'] = data['close'].rolling(window=20).std() > 0.002  # High volatility filter

    # Apply the filters and generate signals
    for i in range(1, len(data)):
        if data['Volume_Filter'].iloc[i] and data['Volatility_Filter'].iloc[i]:
            print(f"Smart Buy Signal at {data['time'].iloc[i]} due to high volume/volatility.")
        else:
            print(f"Conditions unfavorable for trading at {data['time'].iloc[i]}.")

# Example: Apply smart trade filters to your historical data
smart_trade_filters(historical_data)







# Function to adjust stop loss to break-even after profit
def manage_trade_after_entry(entry_price, current_price, stop_loss, break_even_threshold):
    """
    Adjust the stop loss to break-even once the current price reaches a threshold beyond the entry price.
    """
    if current_price - entry_price >= break_even_threshold:
        # Move stop loss to entry point
        new_stop_loss = entry_price
        print(f"Stop loss moved to break-even at {new_stop_loss}")
    else:
        new_stop_loss = stop_loss
    return new_stop_loss

# Example: Managing trade after entry
new_stop_loss = manage_trade_after_entry(entry_price=1.12345, current_price=1.12500, stop_loss=1.12200, break_even_threshold=0.002)

# Function to detect divergence between price and RSI
def divergence_analysis(data):
    """
    Detects bearish or bullish divergence between the price and RSI.
    A bearish divergence occurs when RSI increases but price decreases.
    A bullish divergence occurs when RSI decreases but price increases.
    """
    data['RSI'] = ta.RSI(data['close'], timeperiod=14)

    for i in range(1, len(data)):
        if data['RSI'].iloc[i] > data['RSI'].iloc[i-1] and data['close'].iloc[i] < data['close'].iloc[i-1]:
            print(f"Bearish Divergence detected at {data['time'].iloc[i]}")  # Price decreasing but RSI increasing
        elif data['RSI'].iloc[i] < data['RSI'].iloc[i-1] and data['close'].iloc[i] > data['close'].iloc[i-1]:
            print(f"Bullish Divergence detected at {data['time'].iloc[i]}")  # Price increasing but RSI decreasing

# Example: Apply divergence analysis to your data
divergence_analysis(historical_data)







# Function to detect engulfing candlestick patterns
def detect_engulfing_pattern(data):
    """
    Detects bullish and bearish engulfing patterns from historical data.
    """
    for i in range(1, len(data)):
        # Bullish engulfing pattern
        if (data['close'].iloc[i] > data['open'].iloc[i] and 
            data['close'].iloc[i-1] < data['open'].iloc[i-1] and 
            data['close'].iloc[i] > data['open'].iloc[i-1] and 
            data['open'].iloc[i] < data['close'].iloc[i-1]):
            print(f"Bullish Engulfing detected at {data['time'].iloc[i]}")
        
        # Bearish engulfing pattern
        elif (data['close'].iloc[i] < data['open'].iloc[i] and 
              data['close'].iloc[i-1] > data['open'].iloc[i-1] and 
              data['close'].iloc[i] < data['open'].iloc[i-1] and 
              data['open'].iloc[i] > data['close'].iloc[i-1]):
            print(f"Bearish Engulfing detected at {data['time'].iloc[i]}")

# Example: Apply candlestick pattern detection
detect_engulfing_pattern(historical_data)


# Function to log each trade with detailed analysis
trade_log = []

def log_trade(symbol, entry_price, exit_price, profit_loss, reason):
    """
    Logs detailed information of each trade including symbol, entry/exit prices, profit/loss, and reason.
    """
    trade_details = {
        'symbol': symbol,
        'entry_price': entry_price,
        'exit_price': exit_price,
        'profit_loss': profit_loss,
        'reason': reason
    }
    trade_log.append(trade_details)
    print(f"Logged trade: {trade_details}")

# Example: Log a trade
log_trade(symbol="EURUSD", entry_price=1.12345, exit_price=1.12500, profit_loss=155, reason="RSI Buy Signal")








# Function to adjust risk based on market volatility using ATR
def adjust_risk_based_on_volatility(account_balance, risk_percent, atr_value):
    """
    Adjusts the risk by calculating a lot size based on the account balance,
    risk percentage, and ATR (Average True Range) for market volatility.
    """
    max_risk = account_balance * (risk_percent / 100)
    risk_adjusted_lot = max_risk / atr_value
    return round(risk_adjusted_lot, 2)

# Example: Adjust risk based on volatility
adjusted_lot = adjust_risk_based_on_volatility(account_balance=10000, risk_percent=1, atr_value=0.0015)
print(f"Adjusted Lot Size: {adjusted_lot}")


# Function to implement a seasonal trading strategy based on monthly average returns
def seasonal_trading_strategy(data):
    """
    Implements a seasonal trading strategy by analyzing the monthly average returns
    and generating buy/sell signals based on seasonal patterns.
    """
    # Extract the month from the time data
    data['Month'] = pd.DatetimeIndex(data['time']).month
    
    # Group by month and calculate the mean percentage change for each month
    monthly_returns = data.groupby('Month')['close'].apply(lambda x: x.pct_change().mean())

    # Reindex to ensure all months (1 to 12) are included, even if missing
    monthly_returns = monthly_returns.reindex(range(1, 13), fill_value=0)
    
    for i in range(1, len(data)):
        current_month = data['Month'].iloc[i]
        
        # If the historical data shows a pattern of positive returns in this month
        if monthly_returns[current_month] > 0:
            print(f"Seasonal Buy Signal for {current_month} at {data['time'].iloc[i]}")
        else:
            print(f"Seasonal Sell Signal for {current_month} at {data['time'].iloc[i]}")

# Example: Apply the seasonal strategy to your historical data
seasonal_trading_strategy(historical_data)








# Function to train a neural network for predicting price movement
def neural_network_trading(data):
    """
    Trains a neural network using past 10 closing prices to predict future price movement.
    A prediction of 1 means upward movement, while 0 means downward movement.
    """
    # Prepare the data (using past 10 closing prices as features)
    X = np.array([data['close'].values[i-10:i] for i in range(10, len(data))])
    y = np.where(data['close'].values[10:] > data['close'].values[9:-1], 1, 0)  # 1 for up, 0 for down

    # Train a neural network
    model = MLPClassifier(hidden_layer_sizes=(50, 50), max_iter=1000, random_state=42)
    model.fit(X, y)

    # Predict future movement using the last 10 closing prices
    last_10_prices = data['close'].values[-10:]
    prediction = model.predict(last_10_prices.reshape(1, -1))

    # Output prediction results
    if prediction == 1:
        print("Neural Network predicts an upward movement.")
    else:
        print("Neural Network predicts a downward movement.")

# Example: Apply neural network to your historical data
neural_network_trading(historical_data)










# Function to implement advanced money management techniques
def advanced_money_management(account_balance, trade_result, consecutive_wins, consecutive_losses):
    """
    Adjusts the lot size dynamically based on consecutive wins or losses using advanced money management techniques.
    
    Parameters:
    - account_balance: The current balance of the trading account.
    - trade_result: The result of the latest trade (win/loss).
    - consecutive_wins: The number of consecutive wins.
    - consecutive_losses: The number of consecutive losses.
    
    Returns:
    - lot_size: The dynamically adjusted lot size.
    """
    # Set the base, max, and min lot sizes
    base_lot_size = 0.01
    max_lot_size = 0.5
    min_lot_size = 0.01

    # Increase lot size after consecutive wins
    if consecutive_wins >= 2:
        lot_size = base_lot_size * (1 + 0.5 * consecutive_wins)
    # Decrease lot size after consecutive losses
    elif consecutive_losses >= 2:
        lot_size = base_lot_size * (1 - 0.5 * consecutive_losses)
    else:
        lot_size = base_lot_size

    # Ensure the lot size stays within defined limits
    lot_size = max(min(lot_size, max_lot_size), min_lot_size)
    
    print(f"Advanced Money Management set lot size to: {lot_size}")
    return lot_size

# Example: Apply advanced money management to your trading
lot_size = advanced_money_management(account_balance=10000, trade_result=1, consecutive_wins=3, consecutive_losses=0)






# Function to stop trading based on weekly performance
def auto_stop_trading(weekly_profit, weekly_loss, max_profit_threshold=1000, max_loss_threshold=-500):
    """
    Function to stop trading based on weekly profit or loss reaching set thresholds.
    
    Parameters:
    - weekly_profit: The total profit for the current week.
    - weekly_loss: The total loss for the current week.
    - max_profit_threshold: The profit level at which trading stops for the week (default is 1000).
    - max_loss_threshold: The loss level at which trading stops for the week (default is -500).
    
    Returns:
    - True if trading should be stopped, False otherwise.
    """
    if weekly_profit >= max_profit_threshold:
        print(f"Max weekly profit reached: {weekly_profit}. Stopping trading.")
        return True  # Stop trading
    elif weekly_loss <= max_loss_threshold:
        print(f"Max weekly loss reached: {weekly_loss}. Stopping trading.")
        return True  # Stop trading
    return False  # Continue trading

# Example: Apply auto stop trading logic
stop_trading = auto_stop_trading(weekly_profit=1200, weekly_loss=-300)









# Function to manage multiple trading strategies
def multi_strategy_management(data, strategy_functions):
    """
    Function to execute multiple trading strategies on the given data.
    
    Parameters:
    - data: The historical or live data on which strategies will be applied.
    - strategy_functions: A list of strategy functions to be executed.
    
    Each strategy function must accept 'data' as an argument.
    """
    for strategy_function in strategy_functions:
        strategy_function(data)

# Example strategies
def rsi_strategy(data):
    print("Executing RSI Strategy...")
    # Your RSI strategy logic here

def macd_strategy(data):
    print("Executing MACD Strategy...")
    # Your MACD strategy logic here

# Example: Run multiple strategies
strategies = [rsi_strategy, macd_strategy]
multi_strategy_management(historical_data, strategies)





# Function to detect session-based price gaps
def session_gap_analysis(data):
    """
    Detects gaps between session close and open prices.

    Parameters:
    - data: DataFrame containing 'open', 'close', and 'time' columns.
    """
    for i in range(1, len(data)):
        # Check if there's a gap between the previous close and the current open
        previous_close = data['close'].iloc[i-1]
        current_open = data['open'].iloc[i]
        
        if current_open > previous_close * 1.01:
            print(f"Gap up detected at {data['time'].iloc[i]}")
        elif current_open < previous_close * 0.99:
            print(f"Gap down detected at {data['time'].iloc[i]}")

# Example: Apply session gap analysis to your data
session_gap_analysis(historical_data)




# Function to optimize operations using multithreading
def run_in_parallel(*functions):
    """
    Runs multiple functions in parallel using multithreading.
    
    Parameters:
    - functions: A list of functions to be executed in parallel.
    
    Returns:
    - A list of results from each function.
    """
    with concurrent.futures.ThreadPoolExecutor(max_workers=4) as executor:
        results = executor.map(lambda func: func(), functions)
        return list(results)

# Example: Running multiple calculations in parallel
def calculate_rsi():
    # Placeholder for RSI calculation logic
    print("Calculating RSI...")

def calculate_macd():
    # Placeholder for MACD calculation logic
    print("Calculating MACD...")

# Run both calculations in parallel
run_in_parallel(calculate_rsi, calculate_macd)







# Function to log live performance in a CSV file
def log_live_performance(trade_info, file_name="live_performance.csv"):
    """
    Logs the live trading performance to a CSV file.
    
    Parameters:
    - trade_info: Dictionary containing trade details.
    - file_name: Name of the CSV file to store the logs (default is "live_performance.csv").
    """
    fieldnames = ['Time', 'Symbol', 'Action', 'Lot Size', 'Profit/Loss', 'Balance']
    
    # Open the file in append mode ('a'), ensuring no blank lines (newline='') in between rows
    with open(file_name, mode='a', newline='') as file:
        writer = csv.DictWriter(file, fieldnames=fieldnames)
        
        # If the file is empty, write the header
        if file.tell() == 0:
            writer.writeheader()
        
        # Write the trade information
        writer.writerow(trade_info)

# Function to monitor and log the trade
def monitor_trade(trade_data):
    """
    Prepares trade information and logs it.
    
    Parameters:
    - trade_data: Dictionary containing the trade details such as 'symbol', 'action', 'lot_size', 'profit_loss', and 'balance'.
    """
    trade_info = {
        'Time': time.strftime("%Y-%m-%d %H:%M:%S"),
        'Symbol': trade_data['symbol'],
        'Action': trade_data['action'],
        'Lot Size': trade_data['lot_size'],
        'Profit/Loss': trade_data['profit_loss'],
        'Balance': trade_data['balance']
    }
    
    log_live_performance(trade_info)

# Simulate a trade data input for testing purposes
trade_data = {
    'symbol': "EURUSD",
    'action': "Buy",
    'lot_size': 0.1,
    'profit_loss': 150,
    'balance': 10150
}

# Log the simulated trade
monitor_trade(trade_data)








def calculate_seasonal_signal(data):
    """
    Function to calculate seasonal signals (Buy/Sell) based on monthly average returns.
    
    Parameters:
    - data: DataFrame with a 'time' and 'close' column.
    
    Returns:
    - DataFrame with an added 'Seasonal_Signal' column indicating 'Buy' or 'Sell' based on monthly average returns.
    """
    # Extract the month from the time data
    data['Month'] = pd.DatetimeIndex(data['time']).month
    
    # Group by month and calculate the mean percentage change for each month
    monthly_returns = data.groupby('Month')['close'].apply(lambda x: x.pct_change().mean())

    # Reindex to ensure all months (1 to 12) are included, even if missing
    monthly_returns = monthly_returns.reindex(range(1, 13), fill_value=0)

    # Add a new column "Seasonal_Signal" based on the monthly returns
    data['Seasonal_Signal'] = data['Month'].apply(lambda x: 'Buy' if monthly_returns[x] > 0 else 'Sell')

    return data



# Define the strategies as individual functions

# RSI Strategy
def rsi_strategy(data_row, balance):
    if data_row['RSI'] < 30:
        print(f"RSI Buy signal at {data_row['time']}")
        return 100  # Example profit
    elif data_row['RSI'] > 70:
        print(f"RSI Sell signal at {data_row['time']}")
        return -100  # Example loss
    return None

# MACD Strategy
def macd_strategy(data_row, balance):
    if data_row['MACD'] > data_row['MACD_signal']:
        print(f"MACD Buy signal at {data_row['time']}")
        return 100  # Example profit
    elif data_row['MACD'] < data_row['MACD_signal']:
        print(f"MACD Sell signal at {data_row['time']}")
        return -100  # Example loss
    return None

# Bollinger Bands Strategy with Volatility Filter
def bollinger_bands_strategy(data_row, balance):
    if data_row['close'] > data_row['Upper_Band']:
        print(f"Bollinger Bands Sell signal at {data_row['time']}")
        return -100  # Example loss
    elif data_row['close'] < data_row['Lower_Band'] and data_row['Volatility_Filter']:
        print(f"Bollinger Bands Buy signal with volatility at {data_row['time']}")
        return 150  # Example profit
    return None

# Confluence Strategy (combining RSI & MACD)
def confluence_strategy(data_row, balance):
    if data_row['RSI'] < 30 and data_row['MACD'] > data_row['MACD_signal']:
        print(f"Confluence Buy signal at {data_row['time']}")
        return 150  # Stronger profit
    elif data_row['RSI'] > 70 and data_row['MACD'] < data_row['MACD_signal']:
        print(f"Confluence Sell signal at {data_row['time']}")
        return -150  # Stronger loss
    return None

# Seasonal Pattern Detection Strategy
def seasonal_pattern_strategy(data_row, balance):
    current_month = pd.DatetimeIndex([data_row['time']]).month[0]
    if data_row['Seasonal_Signal'] == 'Buy':
        print(f"Seasonal Buy Signal in month {current_month} at {data_row['time']}")
        return 100  # Example profit
    elif data_row['Seasonal_Signal'] == 'Sell':
        print(f"Seasonal Sell Signal in month {current_month} at {data_row['time']}")
        return -100  # Example loss
    return None

# Neural Network Prediction Strategy
def neural_network_strategy(data_row, balance):
    if data_row['Neural_Prediction'] == 'Buy':
        print(f"Neural Network Buy prediction at {data_row['time']}")
        return 150  # Example profit
    elif data_row['Neural_Prediction'] == 'Sell':
        print(f"Neural Network Sell prediction at {data_row['time']}")
        return -150  # Example loss
    return None





# Advanced Money Management Strategy
def advanced_money_management_strategy(data_row, balance, consecutive_wins, consecutive_losses):
    base_lot_size = 0.01
    max_lot_size = 0.5
    min_lot_size = 0.01

    if consecutive_wins >= 2:
        lot_size = base_lot_size * (1 + 0.5 * consecutive_wins)
    elif consecutive_losses >= 2:
        lot_size = base_lot_size * (1 - 0.5 * consecutive_losses)
    else:
        lot_size = base_lot_size

    lot_size = max(min(lot_size, max_lot_size), min_lot_size)
    print(f"Advanced Money Management set lot size to: {lot_size}")
    return lot_size

# Multi-timeframe Analysis
def multi_timeframe_analysis(data_row, balance):
    if data_row['Higher_Timeframe_Trend'] == 'Bullish':
        print(f"Multi-Timeframe Buy signal at {data_row['time']}")
        return 100  # Example profit
    elif data_row['Higher_Timeframe_Trend'] == 'Bearish':
        print(f"Multi-Timeframe Sell signal at {data_row['time']}")
        return -100  # Example loss
    return None

# Dynamic Take Profit & Stop Loss
def dynamic_take_profit_stop_loss(data_row, balance, atr_value):
    dynamic_tp = atr_value * 2  # Take profit is twice the ATR value
    dynamic_sl = atr_value * 1.5  # Stop loss is 1.5 times the ATR value
    print(f"Take profit set to {dynamic_tp} and Stop loss set to {dynamic_sl} based on ATR at {data_row['time']}")
    return dynamic_tp, dynamic_sl


# Multi-strategy function (with seasonal strategy integrated)
def your_strategy_function(data_row, balance):
    profit_loss = 0
    atr_value = data_row['ATR']  # ATR values are available in the data

    # Apply all strategies and accumulate results
    profit_loss += rsi_strategy(data_row, balance) or 0
    profit_loss += macd_strategy(data_row, balance) or 0
    profit_loss += bollinger_bands_strategy(data_row, balance) or 0
    profit_loss += confluence_strategy(data_row, balance) or 0
    profit_loss += seasonal_pattern_strategy(data_row, balance) or 0  # Seasonal pattern strategy
    profit_loss += neural_network_strategy(data_row, balance) or 0
    profit_loss += multi_timeframe_analysis(data_row, balance) or 0

    # Apply advanced money management (with dummy consecutive wins/losses values)
    lot_size = advanced_money_management_strategy(data_row, balance, consecutive_wins=2, consecutive_losses=0)
    
    # Apply dynamic take profit and stop loss
    dynamic_take_profit, dynamic_stop_loss = dynamic_take_profit_stop_loss(data_row, balance, atr_value)

    return profit_loss if profit_loss != 0 else None  # Return result if any strategy triggers

# 1. Ensure ATR is calculated before backtesting
historical_data = calculate_atr(historical_data)
historical_data = calculate_seasonal_signal(historical_data)

# Function for backtesting a strategy
def backtest_strategy(data, strategy_function):
    initial_balance = 10000
    balance = initial_balance
    trades = 0
    wins = 0
    losses = 0

    # Iterate through historical data
    for i in range(1, len(data)):
        trade_result = strategy_function(data.iloc[i], balance)

        if trade_result is not None:
            trades += 1
            balance += trade_result
            if trade_result > 0:
                wins += 1
            else:
                losses += 1

    win_rate = (wins / trades) * 100 if trades > 0 else 0
    print(f"Backtest complete: {trades} trades, {win_rate:.2f}% win rate, final balance: {balance:.2f}")

    # Plot results
    plt.plot(data['time'], data['close'], label='Price')
    plt.title('Backtest Results')
    plt.legend()
    plt.show()



# Function to continuously learn from past trades and improve
def continuous_learning(data, previous_trades):
    # Ensure no missing values in training data
    if previous_trades.isnull().any().any():
        print("Missing values in previous_trades, cannot train model.")
        return

    # Prepare training data
    X = np.array(previous_trades[['entry_price', 'exit_price', 'profit_loss']])
    y = previous_trades['outcome']  # 1 for win, 0 for loss

    # Train the model (Random Forest)
    model = RandomForestClassifier(n_estimators=100, random_state=42)
    model.fit(X, y)

    # Prepare future data for prediction
    future_data = np.array(data[['entry_price', 'exit_price', 'profit_loss']])
    predictions = model.predict(future_data)

    # Make trading decisions based on predictions
    for i, prediction in enumerate(predictions):
        if prediction == 1:
            print(f"Positive prediction at {data['time'].iloc[i]}. Consider buying.")
        else:
            print(f"Negative prediction at {data['time'].iloc[i]}. Consider selling.")

# Function to add higher timeframe trend to the lower timeframe data
def add_higher_timeframe_trend(data, higher_timeframe_data):
    if len(higher_timeframe_data) == 0:
        print("No data fetched for the higher timeframe.")
        return data

    # Initialize the column with neutral trend
    data['Higher_Timeframe_Trend'] = 'Neutral'

    # Use the simple moving average (SMA) from the higher timeframe to define the trend
    higher_timeframe_sma = ta.SMA(higher_timeframe_data['close'], timeperiod=50)

    # Align higher timeframe data with the lower timeframe
    for i in range(min(len(data), len(higher_timeframe_data))):
        if higher_timeframe_data['close'].iloc[i] > higher_timeframe_sma.iloc[i]:
            data.at[i, 'Higher_Timeframe_Trend'] = 'Bullish'
        elif higher_timeframe_data['close'].iloc[i] < higher_timeframe_sma.iloc[i]:
            data.at[i, 'Higher_Timeframe_Trend'] = 'Bearish'

    return data







def add_higher_timeframe_trend(data, higher_timeframe_data):
    # Add column for higher timeframe trend with a default value of 'Neutral'
    data['Higher_Timeframe_Trend'] = 'Neutral'

    # Calculate SMA (Simple Moving Average) for higher timeframe
    higher_timeframe_sma = ta.SMA(higher_timeframe_data['close'], timeperiod=50)

    # Use vectorized conditions for better performance
    bull_mask = higher_timeframe_data['close'] > higher_timeframe_sma
    bear_mask = higher_timeframe_data['close'] < higher_timeframe_sma

    # Apply the trends based on the conditions
    data.loc[bull_mask, 'Higher_Timeframe_Trend'] = 'Bullish'
    data.loc[bear_mask, 'Higher_Timeframe_Trend'] = 'Bearish'

    return data


# Fetch higher timeframe data (e.g., 4 hours)
higher_timeframe_data = fetch_historical_data(symbol="EURUSD", timeframe=mt5.TIMEFRAME_H4, years=5)


# Volume check and applying filters based on volume or volatility
if 'volume' not in historical_data.columns or historical_data['volume'].isnull().all():
    print("Volume data is missing in the fetched data.")
    # Use volatility as a proxy if volume is missing
    historical_data['Volume_Filter'] = historical_data['close'].rolling(window=20).std() > 0.002
else:
    # Apply volume filter
    historical_data['Volume_Filter'] = historical_data['volume'] > historical_data['volume'].rolling(window=50).mean()


def add_neural_network_predictions(data):
    # Prepare the data for training (using the previous 10 closing prices)
    X = np.array([data['close'].values[i-10:i] for i in range(10, len(data))])
    
    # Initialize the MLPClassifier (Neural Network)
    model = MLPClassifier(hidden_layer_sizes=(50, 50), max_iter=1000, random_state=42)

    # Target y (Buy if price increases, Sell if price decreases)
    y = np.where(data['close'].values[10:] > data['close'].values[9:-1], 'Buy', 'Sell')

    # Train the model
    model.fit(X, y)

    # Generate predictions
    predictions = model.predict(X)

    # Add the predictions to the data with 'None' for the first 10 rows
    data['Neural_Prediction'] = np.concatenate([['None'] * 10, predictions])

    return data


# Define your previous trades data
data = {
    'entry_price': [1.12345, 1.12400, 1.12100],
    'exit_price': [1.12500, 1.12300, 1.12250],
    'profit_loss': [155, -100, 50],
    'outcome': [1, 0, 1]  # 1 for win, 0 for loss
}
your_previous_trades = pd.DataFrame(data)

# Step 1: Add higher timeframe trend analysis to historical data
historical_data = add_higher_timeframe_trend(historical_data, higher_timeframe_data)

# Step 2: Add neural network predictions to historical data before backtesting
historical_data = add_neural_network_predictions(historical_data)

# Step 3: Apply backtesting to your strategy
backtest_strategy(historical_data, your_strategy_function)

# Step 4: Apply machine learning for continuous improvement using previous trades
continuous_learning(historical_data, your_previous_trades)
